The Kindred presentation framework seeks to reduce repetition as much as possible in application creation. Whereas in modern applications it is typical to describe the same object in three or five different places (as with the LAMP stack: once in the SQL schema, twice in PHP--once for the form and once for the presentation, once in HTML, and once in javascript to create reactivity), the Kindred renderer lets you describe each object *once* in plain JSON, and creates reactive representations from that. [**FUTURE**: Though not covered here, this same object can be both renderered and placed in Kindred's peer-to-peer distribution system with a single call.]

<div class="note">
The web framework that has come closest to eliminating the need for redundant object descriptions is [Meteor](meteor.com). Here, a typical object only has to be described three times -- twice in templates and once to link it to the database.
</div> 

Our framework strives to be almost invisible. It allows us to describe an object *once* as we would natually describe it in javascript, and then feed it to different renderers for different uses. Creating different presentations is no longer a matter of writing different html templates, but of finding the right renderer for our situation. Presenting a form to edit an object's and presenting a polished presentation of it can be done with only two lines of code.  



Renderers are easily overriden and extended, so if someone defines a renderer that *almost* does what you want, you can get the desired behavior by changing only a few fields.

One primarily interacts with the renderer through three calls:

```javascript
// To tell the renderer that a new presentation is available:
renderer.register("mode", renderer_definition);

// To tell the renderer to use a certain presentation:
renderer.use("mode");

// To render a javascript **object** as a child of **parent_element**,
// using the current mode:
renderer.present(object, parent_element, options); 

// TODO: To remove an **object** from our presentation, we can call:
renderer.remove(object);
```

Once an object has been passed to *present()*, it becomes reactive, meaning changing fields of that object will trigger the renderer to re-present that part of the object. [TODO:This includes changes to arrays.] [TODO: Objects can be passed to multiple presentations, and will be reactive for all of them.]

Defining renderers is done by passing an object to *register()* that describes how the renderer should respond to certain types and keywords it encounters while presenting the object. Essentially, the renderer will create a DOM element for every object it encounters, calling specific functions for user-defined keywords and type-specific functions for everything else. For example, if an object is:

```javascript 
{
    hello: "world",
    num: 2,
    other: function() {
        console.log("");
    },
    onclick: function() {
        alert("hi again");
    },
}
```

The renderer would call one function to present the **hello** *string* "world" in DOM, another to present the **num** *number* 2, and yet another to present the **other** *function*. Since the **onclick** field maps to a keyword, a special function would be used to place it in DOM (in this case making it so that when the object's element is clicked, it will call an alert). 

One can define custom keywords and type handlers by creating a renderer description. This is a javascript object that looks like:

```javascript
var custom_renderer = {
    string: function(element, text, context) {
        // Function that takes the *text* string, and 
        // creates a DOM representation with *element*
        // serving as a reference point into the DOM.  
        
        // Context refers to the original object being renderer.   
    },
    number: function(element, num, context) {
        // Same as above, but will be called when the 
        // typeof field === "number".
    },

    // Keywords live in the *of* object.
    of: {
        keyword: function(element, data, context) {
            // Function to handle whatever *data* is.
            // This can be used to set attributes of
            // *element*, or set up methods to handle
            // user input or anything else.
        },
    }
}
```

In addition to type and keyword handlers, one can define a *preprocess()* function that changes the object being rendered before it is presented.

```javascript
custom_renderer.preprocess = function(object) {
    // Change the object in some way (e.g. apply styles)
    object.style = {
        backgroundColor: "red",
    };

    // Then return the changed object
    return object;
};
```


<div style="color:#666">
**NOTE:** This stuff will likely all be wrapped up into the templating system.<br/>
TODO: Object **bases** can be used in conjunction with the *preprocess()* method. A **base** is essentially a set of default fields that get used when they are undefined in the object being presented. For example, if the renderer contains:
> 
> ```javascript
> custom_renderer.base = {
>     base1: {
>         style: {
>             backgroundColor: "red",
>         }
>         html: "p",
>     },
> }
> ```
> 
> Then any object that has a field **base**:"base1" will gain these fields prior to being rendered.

</div>

